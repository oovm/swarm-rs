// This file was generated by Peginator v0.6.0 built at 1671008734
// CRC-32/ISO-HDLC of the grammar file: 5436615f
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct SwarmParser {
    pub statements: SwarmStatements,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum SwarmStatements {
    DefineDeclare(DefineDeclare),
    NamespaceDeclare(NamespaceDeclare),
}
#[derive(Debug, Clone)]
pub struct NamespaceDeclare {
    pub namespace: NamespaceNode,
}
#[derive(Debug, Clone)]
pub struct DefineDeclare {
    pub namespace: NamespaceNode,
    pub parameters: Option<DefineArguments>,
    pub body: BlockNode,
}
#[derive(Debug, Clone)]
pub struct DefineArguments {
    pub args: Vec<DefineArgument>,
}
#[derive(Debug, Clone)]
pub struct DefineArgument {
    pub name: IdentifierNode,
    pub r#type: Option<TypeNode>,
    pub value: Option<ExpressionNode>,
}
#[derive(Debug, Clone)]
pub struct BlockNode {
    pub statements: Vec<BlockStatementNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum BlockStatementNode {
    NumberNode(NumberNode),
    StringNode(StringNode),
}
#[derive(Debug, Clone)]
pub struct TypeNode {
    pub id: IdentifierNode,
}
#[derive(Debug, Clone)]
pub struct ExpressionNode;
#[derive(Debug, Clone)]
pub struct KeyValueNode {
    pub key: KeyNode,
    pub value: ValueNode,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum KeyNode {
    IdentifierNode(IdentifierNode),
    StringNode(StringNode),
}
#[derive(Debug, Clone)]
pub struct StringNode {
    pub hint: Option<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NumberNode {
    pub num: Num,
    pub hint: Option<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Num {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NamespaceNode {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NamespaceSplit;
#[derive(Debug, Clone)]
pub struct IdentifierNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct SpecialNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
pub type Dot = char;
pub type Split = char;
impl peginator_generated::PegParserAdvanced<()> for SwarmParser {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_defined: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_SwarmParser(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_defined,
            ),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser, PegParserAdvanced,
        PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod SwarmParser_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: statements, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_SwarmStatements(state, &mut *global))?;
            let ParseOk { state, .. } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = SwarmStatements;
    }
    #[inline]
    pub(super) fn parse_SwarmParser<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SwarmParser> {
        global.tracer.print_trace_start(&state, "SwarmParser");
        let result = {
            let result = SwarmParser_impl::parse(state, global)?.map(|r| super::SwarmParser { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SwarmStatements_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceDeclare(state, global))
                        .map_inner(Parsed__override::NamespaceDeclare)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_DefineDeclare(state, global))
                        .map_inner(Parsed__override::DefineDeclare)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::SwarmStatements as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_SwarmStatements<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SwarmStatements> {
        global.tracer.print_trace_start(&state, "SwarmStatements");
        let result = {
            let result = SwarmStatements_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod NamespaceDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "namespace"))
                .discard_result()?;
            let ParseOk { result: namespace, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, &mut *global))?;
            Ok(ParseOk { result: namespace, state })
        }
        pub type Parsed = NamespaceNode;
    }
    #[inline]
    pub(super) fn parse_NamespaceDeclare<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceDeclare> {
        global.tracer.print_trace_start(&state, "NamespaceDeclare");
        let result = {
            let result = NamespaceDeclare_impl::parse(state, global)?.map(|r| super::NamespaceDeclare { namespace: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefineDeclare_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "def"))
                .discard_result()?;
            let ParseOk { result: namespace, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, &mut *global))?;
            let ParseOk { result: parameters, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DefineArguments(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { namespace, parameters, body }, state })
        }
        pub struct Parsed {
            pub namespace: NamespaceNode,
            pub parameters: Option<DefineArguments>,
            pub body: BlockNode,
        }
    }
    #[inline]
    pub(super) fn parse_DefineDeclare<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineDeclare> {
        global.tracer.print_trace_start(&state, "DefineDeclare");
        let result = {
            let result = DefineDeclare_impl::parse(state, global)?.map(|r| super::DefineDeclare {
                namespace: r.namespace,
                parameters: r.parameters,
                body: r.body,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefineArguments_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_DefineArgument(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<DefineArgument>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
                }
                pub type Parsed = Vec<DefineArgument>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_DefineArgument(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<DefineArgument>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<DefineArgument>;
    }
    #[inline]
    pub(super) fn parse_DefineArguments<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineArguments> {
        global.tracer.print_trace_start(&state, "DefineArguments");
        let result = {
            let result = DefineArguments_impl::parse(state, global)?.map(|r| super::DefineArguments { args: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefineArgument_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()?;
                    let ParseOk { result: r#type, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_TypeNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: r#type, state })
                }
                pub type Parsed = Option<TypeNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<TypeNode>;
        }
        mod part_2 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: name, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { result: r#type, state } = part_1::parse(state, global)?;
            let ParseOk { result: value, state } = part_2::parse(state, global)?;
            Ok(ParseOk { result: Parsed { name, r#type, value }, state })
        }
        pub struct Parsed {
            pub name: IdentifierNode,
            pub r#type: Option<TypeNode>,
            pub value: Option<ExpressionNode>,
        }
    }
    #[inline]
    pub(super) fn parse_DefineArgument<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineArgument> {
        global.tracer.print_trace_start(&state, "DefineArgument");
        let result = {
            let result = DefineArgument_impl::parse(state, global)?.map(|r| super::DefineArgument {
                name: r.name,
                r#type: r.r#type,
                value: r.value,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod BlockNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                    .discard_result()?;
                let ParseOk { result: mut statements, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_BlockStatementNode(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_statements_with, state } = parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_BlockStatementNode(state, &mut *global))
                    .map_inner(|result| vec![result])
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
                statements.extend(extend_statements_with);
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                    .discard_result()?;
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<BlockStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<BlockStatementNode>;
    }
    #[inline]
    pub(super) fn parse_BlockNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BlockNode> {
        global.tracer.print_trace_start(&state, "BlockNode");
        let result = {
            let result = BlockNode_impl::parse(state, global)?.map(|r| super::BlockNode { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod BlockStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NumberNode(state, global))
                        .map_inner(Parsed__override::NumberNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::BlockStatementNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_BlockStatementNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BlockStatementNode> {
        global.tracer.print_trace_start(&state, "BlockStatementNode");
        let result = {
            let result = BlockStatementNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod TypeNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
        }
        pub type Parsed = IdentifierNode;
    }
    #[inline]
    pub(super) fn parse_TypeNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TypeNode> {
        global.tracer.print_trace_start(&state, "TypeNode");
        let result = {
            let result = TypeNode_impl::parse(state, global)?.map(|r| super::TypeNode { id: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExpressionNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_StringNode(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_ExpressionNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExpressionNode> {
        global.tracer.print_trace_start(&state, "ExpressionNode");
        let result = {
            let result = ExpressionNode_impl::parse(state, global)?.map(|r| super::ExpressionNode {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KeyValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: key, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_KeyNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: value, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_ValueNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { key, value }, state })
        }
        pub struct Parsed {
            pub key: KeyNode,
            pub value: ValueNode,
        }
    }
    #[inline]
    pub(super) fn parse_KeyValueNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KeyValueNode> {
        global.tracer.print_trace_start(&state, "KeyValueNode");
        let result = {
            let result = KeyValueNode_impl::parse(state, global)?.map(|r| super::KeyValueNode { key: r.key, value: r.value });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KeyNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, global))
                        .map_inner(Parsed__override::IdentifierNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::KeyNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_KeyNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KeyNode> {
        global.tracer.print_trace_start(&state, "KeyNode");
        let result = {
            let result = KeyNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for KeyNode {
        fn position(&self) -> &std::ops::Range<usize> {
            match self {
                Self::IdentifierNode(x) => x.position(),
                Self::StringNode(x) => x.position(),
            }
        }
    }
    mod StringNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: hint, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                .discard_result()?;
            Ok(ParseOk { result: hint, state })
        }
        pub type Parsed = Option<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_StringNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringNode> {
        global.tracer.print_trace_start(&state, "StringNode");
        let result = {
            let result = StringNode_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::StringNode { hint: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for StringNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NumberNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: num, state } = parse_Num(state, &mut *global)?;
            let ParseOk { result: hint, state } = parse_IdentifierNode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { num, hint }, state })
        }
        pub struct Parsed {
            pub num: Num,
            pub hint: Option<IdentifierNode>,
        }
    }
    #[inline]
    pub(super) fn parse_NumberNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NumberNode> {
        global.tracer.print_trace_start(&state, "NumberNode");
        let result = {
            let result = NumberNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::NumberNode {
                num: r.num,
                hint: r.hint,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NumberNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Num_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_character_range(state.clone(), '0', '9').discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod part_2 {
            use super::*;
            mod optional {
                use super::*;
                mod part_1 {
                    use super::*;
                    mod closure {
                        use super::*;
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut iterations: usize = 0;
                        let mut state = state;
                        loop {
                            match parse_character_range(state.clone(), '0', '9').discard_result() {
                                Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                    state = new_state;
                                }
                                Err(err) => {
                                    state = state.record_error(err);
                                    break;
                                }
                            }
                            iterations += 1;
                        }
                        if iterations == 0 {
                            return Err(state.report_farthest_error());
                        }
                        Ok(ParseOk { result: (), state })
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Dot(state, &mut *global).discard_result()?;
                    let ParseOk { state, .. } = part_1::parse(state, global)?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global).or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state.clone())
                .choice(|state| parse_character_literal(state, '+').discard_result())
                .choice(|state| parse_character_literal(state, '-').discard_result())
                .end()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = part_2::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Num<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Num> {
        global.tracer.print_trace_start(&state, "Num");
        let result = {
            let result = Num_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Num { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Num {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NamespaceNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceSplit(state, &mut *global))
                        .discard_result()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut path: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            path.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: path, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, global)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_NamespaceNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceNode> {
        global.tracer.print_trace_start(&state, "NamespaceNode");
        let result = {
            let result = NamespaceNode_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::NamespaceNode { path: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NamespaceNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NamespaceSplit_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_NamespaceSplit<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceSplit> {
        global.tracer.print_trace_start(&state, "NamespaceSplit");
        let result = {
            let result = NamespaceSplit_impl::parse(state, global)?.map(|r| super::NamespaceSplit {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod IdentifierNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_XID_CONTINUE(state.clone(), &mut *global).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_XID_START(state, &mut *global).discard_result())
                .choice(|state| parse_character_literal(state, '_').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IdentifierNode> {
        global.tracer.print_trace_start(&state, "IdentifierNode");
        let result = {
            let result = IdentifierNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IdentifierNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IdentifierNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod SpecialNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "null"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "default"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SpecialNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SpecialNode> {
        global.tracer.print_trace_start(&state, "SpecialNode");
        let result = {
            let result = SpecialNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                SpecialNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SpecialNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
    #[inline]
    pub(super) fn parse_Dot<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Dot> {
        if let Ok(result) = parse_character_literal(state.clone(), '.') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '。') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Dot" }))
    }
    #[inline]
    pub(super) fn parse_Split<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Split> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), ',') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '，') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Split" }))
    }
}
